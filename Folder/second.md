 - 국소성
	- 서버를 늘린다면, 패턴을 정해서 어디에 저장해야 할지 저장해야 한다.
	- 왜냐하면, 지정하지 않는다면 데이터가 같은 곳 동시에 혹은 한 곳에만 저장될 수 있기 때문이다.


 - 파티셔닝
	- 하나의 DB서버를 여러 대의 서버로 나눈다.
	- 테이블 단위로 나눈다 = 같이 엑세스하는 경우가 많을 때는 합치는 게 좋다
	- 예를 들면 a, b, c, d 테이블이 있을 때, a와 b가 같이 엑세스하는 경우가 많다면, 둘이 같이 묶어서 나누는 게 효율적이다.
	- 왜냐하면, 나눠진 DB서버에서 따로 쿼리를 보내서 합치는 것보다, 처음부터 합치는 게 당연히 효과적이기 때문이다.
	- 그리고 모든 테이블의 수의 용량이 메모리 용량 보다 크다면, 다시 나누는 것이 좋다. 왜냐하면 전부 캐시로 올릴 수 없기 때문이다.


 - 테이블 단위 분할
	- 빅데이터라면, 하나의 테이블로 감당하기 어려울 때가 있다.
	- 이럴 때는 여러 서버에 하나의 테이블을 나눠서 id별로 지정하면 효과적이다.
		Ex) id가 a부터 e까지 1번 DB, f부터 i까지 2번 DB


 - 섬으로 분할
	- 광범위하게 데이터를 액세스할 경우, 캐시에 올리기 어렵다. 왜냐하면 데이터의 폭이 넓기 때문이다.
	- 모든 데이터를 캐시에 올린다는 것은 매우 비효율적으로 동작될 수 있다. 캐시는 말 그대로 자주 사용되는 데이터를 메모리에 올려서
	  빠르게 처리하기 위해 존재하기 때문이다.
 

 - 페이지 캐시 운용
	- OS 기동 직후, 서버를 투입 시, 캐시가 적용되어 있지 않기 때문에 DB파일을 cat한다.
		- 이렇게 하면, 캐시가 메모리에 올라가기 때문에 성능이 좋아진다. Ex) JVM의 JIT Compiler와 비슷한 원리라고 볼 수 있다.

	- 성능 및 부하 테스트 시, 초깃값을 버린다.
		- 왜냐하면, 캐시가 최적화되어 있지 않는 상태에서 실행 시, 속도가 완전히 다르기 때문이다.


 - 인덱스 운용
	- 인덱스를 사용하는 이유는 간단하다, 쿼리를 던질 때 좀 더 빠르게 응답을 받기 위함이다.
	- 그럼 무조건 인덱스를 생성해야 할까?
		- 그렇지 않다. 이건 데이터량에 따라 결정된다.
		- 만일 데이터수가 몇백 몇천 건밖에 되지 않는다면, 굳이 해야 할 필요가 사라진다 혹은 인덱스를 적용했을 때 성능이 더 안 좋게 나올 수 있으며, 쓸데없이 용량을 차지한다.

	- OS 캐시 활용
		- 데이터량이 물리 메모리보다 높지 않게 관리한다.
		- 무조건 순수 DB의 데이터량만 캐시로 메모리에 올리지 않는다.
		- 다른 프로세스도 있기 때문에 관리할 때 주의해야 한다. 따라서, 부족함이 보일 경우, 메모리를 증설해야 한다.

		- 테이블을 설계할 때 스키마를 고려해야 한다.
			- 왜냐하면, 데이터 수가 이미 추측으로도 대용량이 된다면, 추후 컬럼을 추가할 때 방대한 데이터를 감당해야 하기 때문이다.
			- 그래서 대량의 데이터를 저장하는 테이블을 설계할 때는 최대한 용량을 고려해서 만들어야 한다.
			- 정규화를 고려해야 한다.
				- 하나의 테이블에 모든 컬럼이 있다면, 매우 비효율적이다. 왜냐하면, 데이터수가 증가함에 따라 인덱스를 적용하더라도 쿼리가 늦게 응답할 수 있기 때문이다.
				- 따라서, 정규화를 통해 필요한 컬럼 및 선택 컬럼을 나눠서 사용하면 효과적이다.
	

	- Mysql Index는 동작
		- 기본적으로 B+트리를 사용한다.
		- 이진트리는 최대 2개의 자식 노드를 가질 수 있다.
		- B트리는 이진 트리와 달리, 하나의 노드에 많은 정보를 가질 수 있다.
			- 노드의 자료는 정렬되어 있으며, 중복되지 않는다.
			- 그리고 모든 leaf node는 같은 레벨에 존재한다. (leaf node는 끝단에 있는 node를 의미한다.)

		- B+트리는 B트리의 탐색 노드(매 노드를 찾아서 이동)의 단점을 해결한다.
			- 같은 레벨의 모든 키값들이 정렬되어 있으며, leaf node에 모든 자료가 존재하고, 연결리스트로 이어져있기 때문에 탐색 속도에 매우 유리하다.

		- 추가로, leaf node가 아닌 자료를 인덱스 노드라 하며, leaf node 자료를 데이터 노드라고 한다.
			- 따라서, 인덱스 노드는 값이 있는 다음 노드를 가리키는 포인터 주소가 있으며, 데이터 노드는 그 자체에 값이 있다.

		- 기본적으로 한 쿼리당 하나의 인덱스만 작용하며, 여러 개의 인덱스를 적용시키려면, 복합 인덱스를 설정해야 한다.



 - 레플리케이션
	- DB를 마스터와 슬레이브로 분산시킨다.
		- 이렇게 나누는 이유는 안정성의 이유가 있다.
		- 마스터는 데이터 갱신 용도, 슬레이브는 조회 용도로 사용된다.
		- 기본적으로 마스터 1대, 슬레이브 3대로 나눈다.
			- 이유는 마스터 혹은 슬레이브가 고장나더라도, 남은 서버로 한 대는 마스터로 승격시키고, 나머지 한 대는 그대로 운용하면 되기 때문이다.
			- 그래서 슬레이브를 2대로 운용한다면, 위와 같은 상황 직면 시, 해결이 불가능해진다. 추가로, 백업DB도 구성한다.


	- 웹 애플리케이션의 대부분이 참조계열이라면, 마스터의 다중화가 크게 필요하지 않다.
	- 하지만, 갱신계열이 높다면, 테이블을 분할시켜서 하나의 테이블에 데이터를 몰리지 않게 한다. 혹은 NoSQL을 사용한다.














